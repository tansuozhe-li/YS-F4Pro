#include "string.h"
#include "commlib.h"

//为提高运算校率，校验采用查表法：
// -----------------------------------------------------------------------------
// DESCRIPTION: RTU CRC 校验的高位字节表
// -----------------------------------------------------------------------------
static const unsigned char auchCRCHi[] = {
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 
0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 
0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 
0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 
0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 
0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 
0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 
0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 
0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40};

// -----------------------------------------------------------------------------
// DESCRIPTION: RTU CRC 校验的低位字节表
// -----------------------------------------------------------------------------
static const unsigned char auchCRCLo[] = {
0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 
0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 
0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 
0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 
0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 0x11, 0xD1, 0xD0, 0x10, 0xF0, 
0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 
0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 
0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 
0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 
0xE7, 0xE6, 0x26, 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 
0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 
0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 
0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 
0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 0x77, 0xB7, 
0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 
0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 
0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 
0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 
0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40};

///@brief 计算CRC
unsigned short RTU_CRC( unsigned char * puchMsg, unsigned short usDataLen)
{
    unsigned char uchCRCHi; // high byte of CRC initialized
    unsigned char uchCRCLo; // low byte of CRC initialized
    unsigned uIndex; // will index into CRC lookup table
    uchCRCHi = 0xFF;
    uchCRCLo = 0xFF;
    while ( usDataLen-- )
    {
        // calculate the CRC
        uIndex = uchCRCHi ^ (unsigned char)( *puchMsg++ );
        uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex];
        uchCRCLo = auchCRCLo[uIndex];
    }
    return ( uchCRCHi << 8 | uchCRCLo );
}

///@brief 累加计算CRC
void RTU_CRC_update(u_int16_t *crc16, unsigned char * puchMsg, u_int16_t usDataLen)
{
   unsigned char uchCRCHi;      //high byte of CRC initialized
   unsigned char uchCRCLo;      //low byte of CRC initialized
   u_int16_t uIndex;        //will index into CRC lookup table

   uchCRCHi = (*crc16) >> 8;
   uchCRCLo = (*crc16) & 0xFF;

   while(usDataLen--)
   {
       uIndex   = uchCRCHi^(unsigned char)(*puchMsg++);
       uchCRCHi = uchCRCLo^auchCRCHi[uIndex];
       uchCRCLo = auchCRCLo[uIndex];
   }

   *crc16 = (uchCRCHi <<8|uchCRCLo);
}

///@brief 字符串转整数
int StrToInt(char *str)
{
    int value = 0;
    int sign = 1;
    if(*str == '-')
    {
        sign = -1;
        str++;
    }else if(*str == '+')
    {
        str++;
    }
    while((*str) && (*str != '\r') && (*str != ',') && (*str != '.'))
    {
        value = value * 10 +(*str - '0');
        str++;
    
    }
    return sign * value;
}

///@brief 将uint16_t型的数据高低字节调整
u_int16_t UnShortToHighLevelTransfer(u_int16_t Num)
{
    u_int16_t OutUintData = 0;
    u_int8_t NumH = Num >> 8;
    u_int8_t NumL = (u_int8_t)(Num & 0xff);
    OutUintData = (NumL << 8) | NumH;
    return OutUintData;
}

///@brief 将uint32_t型的数据高低字节调整
u_int32_t UnintToHighLevelTransfer(u_int32_t Num)
{
    u_int32_t OutUintData = 0;
    u_int8_t Num1 = (u_int8_t)(Num >> 24);
    u_int8_t Num2 = (u_int8_t)(Num >> 16);
    u_int8_t Num3 = (u_int8_t)(Num >> 8);
    u_int8_t Num4 = (u_int8_t)(Num & 0xff);
    OutUintData = (Num4 << 24) | (Num3 << 16) | (Num2 << 8) | Num1;
    return OutUintData;
}

///@brief 将ASCII码转换成HEX
u_int8_t ASCII_To_Hex(u_int8_t number)
{
 
	if (number >= '0' && number <= '9')
		return (number - 0x30);
 
	else if (number >= 'a' && number <= 'f')
		return ((number - 'a') + 10);
	
	else if (number >= 'A' && number <= 'F')
		return ((number - 'A') + 10);
 
	return (0);
}

///@brief int型数据 去掉最大值与最小值求平均值 
u_int16_t DataRankCalculateAverage(u_int16_t *data, u_int16_t datalen)
{
    u_int16_t Average_Value = 0;
    u_int16_t data_value = 0;
    static u_int16_t Data_buff[255];
    memset(Data_buff, 0, sizeof(Data_buff));
    if (datalen > 255) {
        return 0;
    }
    memcpy(Data_buff, data, datalen*2);
    for(int j = 0; j < datalen-1; j++)//采样值由小到大排列
    {
        for(int k = 0; k < datalen-j-1; k++)
        {
            if(Data_buff[k] > Data_buff[k+1])
            {
               data_value = Data_buff[k];
               Data_buff[k] = Data_buff[k+1];
               Data_buff[k+1] = data_value;
            }
        }
    }
    data_value = 0;
    for(u_int8_t i = 1; i < datalen-1; i++)
    {
        data_value = data_value + Data_buff[i];
    }
    Average_Value = data_value / (datalen - 2);
    return Average_Value;
}

///@brief float型数据 去掉最大值与最小值求平均值 
float FloatDataRankCalculateAverage(float *data, u_int16_t datalen)
{
    float Average_Value = 0;
    float data_value = 0;
    static float Data_buff[255];
    memset(Data_buff, 0, sizeof(Data_buff));
    if (datalen > 255) {
        return 0;
    }
    memcpy(Data_buff, data, datalen*4);
    for(int j = 0; j < datalen-1; j++)//采样值由小到大排列
    {
        for(int k = 0; k < datalen-j-1; k++)
        {
            if(Data_buff[k] > Data_buff[k+1])
            {
               data_value = Data_buff[k];
               Data_buff[k] = Data_buff[k+1];
               Data_buff[k+1] = data_value;
            }
        }
    }
    data_value = 0;
    for(u_int8_t i = 1; i < datalen-1; i++)
    {
        data_value = data_value + Data_buff[i];
    }
    Average_Value = data_value / (datalen - 2);
    return Average_Value;
}

///@brief float型数据，排序求中位数的值
float FloatDataCalculateMedian(float *data, u_int16_t datalen)
{
    float Median_Value = 0;
    float data_value = 0;
    static float Data_buff[255];
    memset(Data_buff, 0, sizeof(Data_buff));
    if (datalen > 255) {
        return 0;
    }
    memcpy(Data_buff, data, datalen*4);
    for(int j = 0; j < datalen-1; j++)//采样值由小到大排列
    {
        for(int k = 0; k < datalen-j-1; k++)
        {
            if(Data_buff[k] > Data_buff[k+1])
            {
               data_value = Data_buff[k];
               Data_buff[k] = Data_buff[k+1];
               Data_buff[k+1] = data_value;
            }
        }
    }
    u_int16_t median_num = datalen / 2;
    if (datalen % 2) { //数据长度是奇数时
        Median_Value = Data_buff[median_num];
    } else { // 数据长度是偶数时
        Median_Value = (Data_buff[median_num-1] + Data_buff[median_num]) / 2;
    }
    return Median_Value;
}

///@brief 累加和校验算法（CheckSum算法）
u_int8_t CS_CheckSum(u_int8_t *buf, u_int8_t len)
{ 
    u_int8_t i, ret = 0;
 
    for(i=0; i<len; i++)
    {
        ret += *(buf++);
    }
     ret = ~ret;
    return ret;
}